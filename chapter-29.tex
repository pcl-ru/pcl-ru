\chapter{Практика. Браузер MP3-файлов}
\label{ch:29}

\thispagestyle{empty}

Заключительным шагом в построении приложения для потокового вещания MP3 является
разработка веб-интерфейса, который позволит пользователям найти песни, которые они хотят
слушать, и добавлять их в списки песен, которые будут использоваться сервером Shoutcast при
получении запроса от MP3-клиента пользователя.  Для этого компонента приложения вы
соберёте вместе несколько компонентов, разработанных в предыдущих главах: базу данных MP3,
макрос \lstinline{define-url-function} из главы~\ref{ch:26} и, конечно, сам сервер Shoutcast.

\section{Списки песен}

Основная идея интерфейса заключается в том, что каждый MP3-клиент, который подключается к
серверу Shoutcast, получает отдельный список песен, который служит источником песен для
сервера Shoutcast.  Список песен также реализует дополнительные функции, не нужные серверу
Shoutcast: используя веб-интерфейс, пользователь сможет добавлять песни в список, удалять
песни из него или изменять порядок проигрывания путём сортировки и перемешивания.

Вы можете определить класс для представления списка песен следующим образом:

\begin{myverb}
(defclass playlist ()
  ((id           :accessor id           :initarg :id)
   (songs-table  :accessor songs-table  :initform (make-playlist-table))
   (current-song :accessor current-song :initform *empty-playlist-song*)
   (current-idx  :accessor current-idx  :initform 0)
   (ordering     :accessor ordering     :initform :album)
   (shuffle      :accessor shuffle      :initform :none)
   (repeat       :accessor repeat       :initform :none)
   (user-agent   :accessor user-agent   :initform "Unknown")
   (lock         :reader   lock         :initform (make-process-lock))))
\end{myverb}

Идентификатор списка песен (\lstinline{id}) является ключом, который вы извлекаете из объекта
\lstinline{request}, переданного \lstinline{find-song-source}, когда происходит поиск списка песен.
Вам не нужно сохранять его в объекте \lstinline{playlist}, но это сделает отладку более
простой, если вы сможете для произвольного объекта \lstinline{playlist} определить его
идентификатор.

Самым главным объектом \lstinline{playlist} является слот \lstinline{songs-table}, который будет
хранить объект \lstinline{table}.  Схема этого объекта будет той же самой, что и схема для
основной базы данных MP3.  Функция \lstinline{make-playlist-table}, которую вы используете для
инициализации \lstinline{songs-table}, очень проста:

\begin{myverb}
(defun make-playlist-table ()
  (make-instance 'table :schema *mp3-schema*))
\end{myverb}

\begin{lrbox}{\chtwonineone}
  \begin{minipage}{\linewidth}
\begin{myverb}
(defpackage :com.gigamonkeys.mp3-browser
  (:use :common-lisp
        :net.aserve
        :com.gigamonkeys.html
        :com.gigamonkeys.shoutcast
        :com.gigamonkeys.url-function
        :com.gigamonkeys.mp3-database
        :com.gigamonkeys.id3v2)
  (:import-from :acl-socket
                :ipaddr-to-dotted
                :remote-host)
  (:import-from :multiprocessing
                :make-process-lock
                :with-process-lock)
  (:export :start-mp3-browser))
\end{myverb}
  \end{minipage}
\end{lrbox}

\textintable{Пакет}{Вы можете определить пакет для кода данной главы с помощью следующего
  определения \lstinline{DEFPACKAGE}:\\[-3pt]

\noindent{}\usebox{\chtwonineone}\\

Поскольку это высокоуровневое приложение, оно использует очень много низкоуровневых
пакетов.  Оно также импортирует три символа из пакета \lstinline{ACL-SOCKET} и два из пакета
\lstinline{MULTIPROCESSING}, поскольку нам необходимы только эти пять символов и не нужны
остальные 139 символов, экспортируемых из этих пакетов.
}

Из-за сохранения списка песен в виде таблицы вы можете использовать функции работы с
базами данных из главы~\ref{ch:27} для работы со списком песен: вы можете добавлять данные
в список песен с помощью \lstinline{insert-row}, удалять песни с помощью \lstinline{delete-rows} и
изменять порядок проигрывания с помощью \lstinline{sort-rows} и \lstinline{shuffle-table}.

Слоты \lstinline{current-song} и \lstinline{current-idx} используются для хранения информации о том,
какая песня сейчас проигрывается: \lstinline{current-song}~-- это объект \lstinline{song}, в то
время как \lstinline{current-idx} является индексом строки в \lstinline{songs-table}, относящейся к
текущей песне. В~разделе <<\nameref{ch29:change-song-list}>> вы увидите, как сделать так, чтобы
\lstinline{current-song} обновлялась, когда изменяется \lstinline{current-idx}.

Слоты \lstinline{ordering} и \lstinline{shuffle} хранят информацию о том, как песни в
\lstinline{songs-table} должны быть упорядочены.  Слот \lstinline{ordering} хранит ключевое слово,
которое описывает то, как таблица \lstinline{songs-table} должна быть отсортирована, когда она
не перемешана. Допустимыми значениями являются \lstinline{:genre}, \lstinline{:artist},
\lstinline{:album} и \lstinline{:song}.  Слот \lstinline{shuffle} содержит одно из ключевых слов
\lstinline{:none}, \lstinline{:song} или \lstinline{:album}, которые определяют, как песни в
\lstinline{songs-table} будут перемешаны, если это нужно.

Слот \lstinline{repeat} также содержит одно из ключевых слов \lstinline{:none}, \lstinline{:song} или
\lstinline{:all}, которые указывают режим повторения песен в списке проигрывания.  Если
\lstinline{repeat} равно \lstinline{:none}, то после проигрывания последней песни из списка
\lstinline{songs-table} \lstinline{current-song} переключается на значение по умолчанию. Когда
\lstinline{repeat} равно \lstinline{:song}, то все время проигрывается одна и та же песня из
\lstinline{current-song}.  И если установлено значение \lstinline{:all}, то после проигрывания
последней песни сервер начинает играть с начала списка.

Слот \lstinline{user-agent} хранит значение заголовка \lstinline{User-Agent}, который отправлен
MP3-клиентом при запросе потока.  Вам нужно его держать исключительно для использования в
веб-интерфейсе~-- заголовок \lstinline{User-Agent} идентифицирует программу, которая выполнила
запрос, так что вы можете отображать это значение на странице, на которой перечислены все
списки песен, так что вам будет легче видеть, какой из списков песен используется с каким
соединением, если к серверу подключено несколько клиентов.

И в заключение слот \lstinline{lock} хранит блокировку процесса (lock), созданную с
помощью функции \lstinline{make-process-lock}, которая является частью пакета
\lstinline{MULTIPROCESSING} из состава Allegro.  Вы будете использовать эту блокировку в
некоторых функциях, которые изменяют список песен, так что вы будете уверены в том, что
только один поток выполнения выполняет изменения списка.  Вы можете определить следующий
макрос, созданный на основе макроса \lstinline{with-process-lock} из пакета
\lstinline{MULTIPROCESSING}, чтобы облегчить написание кода, который должен быть выполнен при
захвате блокировки данного списка песен:

\begin{myverb}
(defmacro with-playlist-locked ((playlist) &body body)
  `(with-process-lock ((lock ,playlist))
     ,@body))
\end{myverb}

Макрос \lstinline{with-process-lock} получает эксклюзивный доступ к блокировке процесса и
затем выполняет переданные выражения, освобождая блокировку после их выполнения.  По
умолчанию \lstinline{with-process-lock} разрешает выполнять рекурсивные блокировки, что
значит, что один и тот же поток выполнения может захватывать одну и ту же блокировку
несколько раз.

\section{Списки песен как источники песен}

Для того чтобы использовать списки песен в качестве источника песен для сервера
Shoutcast, вам нужно реализовать метод для обобщённой функции \lstinline{find-song-source} из
главы~\ref{ch:28}.  Поскольку у вас будет множество списков песен, то вам необходим способ
нахождения нужного списка для конкретного клиента, подключённого к серверу.  Первая часть
работы достаточно легка~-- вы можете определить переменную, которая будет хранить
хэш-таблицу (с операцией сравнения \lstinline{EQUAL}), которую вы сможете использовать для
отображения из некоторого идентификатора в список песен.

\begin{myverb}
(defvar *playlists* (make-hash-table :test #'equal))
\end{myverb}

Вы также можете определить блокировку процесса для защиты доступа к этой хэш-таблице,
например вот так:

\begin{myverb}
(defparameter *playlists-lock* (make-process-lock :name "playlists-lock"))
\end{myverb}

Затем определим функцию, которая производит поиск списка песен по заданному
идентификатору, создавая новый список песен, если это необходимо, и используя
\lstinline{with-process-lock} для обеспечения доступа к хэш-таблице только из одного потока
выполнения\footnote{Описание проблем многопоточного программирования не является темой
  этой книги. Основная идея заключается в том, что если у вас есть несколько потоков
  выполнения (как в нашем случае, когда некоторые потоки выполняют функцию
  \lstinline{shoutcast}, а другие обрабатывают запросы браузера), то вам нужно быть уверенным,
  что только один поток выполнения работает с конкретным объектом в конкретный момент
  времени.  Это делается, чтобы другие потоки выполнения не видели не полностью изменённое
  состояние объекта, в то время как конкретный поток работает с данным объектом.  В~этой
  функции, например, если два новых MP3-клиента подключаются одновременно, то они оба
  будут пытаться добавить записи в таблицу \lstinline{*playlists*}, и могут возникнуть накладки
  в работе.  Функция \lstinline{with-process-lock} обеспечивает, что каждый поток выполнения
  получает эксклюзивный доступ к хэш-таблице на достаточно долгое время для выполнения
  нужной задачи.}\hspace{\footnotenegspace}.

\begin{myverb}
(defun lookup-playlist (id)
  (with-process-lock (*playlists-lock*)
    (or (gethash id *playlists*)
        (setf (gethash id *playlists*) (make-instance 'playlist :id id)))))
\end{myverb}

Далее вы можете реализовать \lstinline{find-song-source} на основе этой функции, а также
функцию \lstinline{playlist-id}, которая получает объект \lstinline{request} от AllegroServe и
возвращает соответствующий идентификатор списка песен.  В~функции \lstinline{find-song-source}
вы также получаете строку \lstinline{User-Agent} из объекта \lstinline{request} и сохраняете её в
объекте \lstinline{playlist}.

\begin{myverb}
(defmethod find-song-source ((type (eql 'playlist)) request)
  (let ((playlist (lookup-playlist (playlist-id request))))
    (with-playlist-locked (playlist)
      (let ((user-agent (header-slot-value request :user-agent)))
        (when user-agent (setf (user-agent playlist) user-agent))))
    playlist))
\end{myverb}

Хитрость заключается в том, как вы реализуете функцию \lstinline{playlist-id}, которая
извлекает идентификатор из объекта \lstinline{request}.  У вас имеется несколько возможностей,
каждая из которых по-разному влияет на интерфейс пользователя.  Вы можете извлечь нужную
информацию из объекта \lstinline{request}, но поскольку вы решили идентифицировать клиента, то
вам нужен какой-то способ связывания пользователя веб-интерфейса с соответствующим списком
песен.

В~данный момент вы можете выбрать тот подход, который <<просто работает>>, поскольку мы
подразумеваем, что есть только один MP3-клиент на компьютере, подключающемся к серверу,
так же как и пользователь, работающий с веб-интерфейсом с компьютера, на котором запущен
MP3-клиент: вы будете использовать IP-адрес компью\-те\-ра пользователя в качестве
идентификатора.  Таким образом вы можете найти соответствующий список песен для запроса,
вне зависимости от того, пришёл запрос от MP3-клиента или от веб-браузера.  Однако вы
обеспечите в веб-интерфейсе возможность выбора другого списка песен, так что единственным
ограничением будет то, что только один MP3-клиент может быть доступен на компьютере
пользователя\pclfootnote{Этот подход также подразумевает, что каждый компьютер пользователя
  имеет уникальный IP-адрес.  Данный подход будет работать до тех пор, пока пользователи
  находятся в одной сети, но он не будет работать, если клиенты подключаются из-за
  межсетевого экрана, который выполняет преобразование адресов.  Развёртывание этого
  приложения вне локальной сети потребует внесения некоторых изменений, но если вы
  захотите развернуть это приложение в глобальной сети, то лучше узнать больше о сетевых
  технологиях, чтобы выбрать соответствующую схему отображения пользователей на списки
  песен.}.  Реализация \lstinline{playlist-id} выглядит примерно так:

\begin{myverb}
(defun playlist-id (request)
  (ipaddr-to-dotted (remote-host (request-socket request))))
\end{myverb}

Функция \lstinline{request-socket} является частью AllegroServe, а \lstinline{remote-host} и
\lstinline{ipaddr-to-dotted} являются частью библиотеки Allegro для работы с сокетами.

Чтобы позволить использовать списки песен в качестве источников песен для сервера
Shoutcast, вам необходимо определить методы \lstinline{current-song}, \lstinline{still-current-p} и
\lstinline{maybe-move-to-next-song}, которые специализируют параметр \lstinline{source} для списка
песен. Метод \lstinline{current-song} уже имеет эту функциональность: путём определения
процедуры доступа \lstinline{current-song} для слота \lstinline{eponymous} вы автоматически
получите метод \lstinline{current-song}, специализированный для списков песен, который будет
возвращать значение этого слота. Однако, для того чтобы сделать доступ к спискам песен
безопасным, вам необходимо блокировать доступ к списку песен до доступа к слоту
\lstinline{current-song}.  В~этом случае самым простым способом будет определение метода
\lstinline{:around}, например вот так:

\begin{myverb}
(defmethod current-song :around ((playlist playlist))
  (with-playlist-locked (playlist) (call-next-method)))
\end{myverb}

Реализация \lstinline{still-current-p} также достаточно простая, предполагая, что мы можем быть
уверены, что \lstinline{current-song} будет обновлён на новый объект \lstinline{song} только тогда,
ког\-да текущая песня действительно сменится.  Вам снова нужно захватить блокировку процесса
для того, чтобы быть уверенным в консистентности состояния списка песен.

\begin{myverb}
(defmethod still-current-p (song (playlist playlist))
  (with-playlist-locked (playlist)
    (eql song (current-song playlist))))
\end{myverb}

Приём заключается в том, чтобы быть уверенным, что поле \lstinline{current-song} будет
обновлено в нужное время.  Однако текущая песня может быть изменена несколькими
способами.  Наиболее очевидным является вызов \lstinline{maybe-move-to-next-song} сервером
Shoutcast.  Но текущая песня также может быть изменена в том случае, когда песни
добавляются к списку проигрывания; когда сервер Shoutcast исчерпывает список доступных
песен или когда изменяется режим повторения в списке проигрывания.

Вместо того чтобы стараться писать в разных частях программы код для определения
необходимости обновления \lstinline{current-song}, вы можете создать функцию
\lstinline{update-current-if-necessary}, которая будет обновлять \lstinline{current-song}, если
объект \lstinline{song} в \lstinline{current-song} больше не соответствует файлу, который должен
проигрываться по информации в \lstinline{current-idx}. Затем, если вы вызовете эту функцию
после любого изменения списка песен, которое может привести к тому, что эти два слота не
будут синхронизированы, то вы будете уверены, что \lstinline{current-song} имеет корректное
значение.  Вот код для функции \lstinline{update-current-if-necessary} и её вспомогательных
функций:

\begin{myverb}
(defun update-current-if-necessary (playlist)
  (unless (equal (file (current-song playlist))
                 (file-for-current-idx playlist))
    (reset-current-song playlist)))

(defun file-for-current-idx (playlist)
  (if (at-end-p playlist)
    nil
    (column-value (nth-row (current-idx playlist) (songs-table playlist)) :file)))

(defun at-end-p (playlist)
  (>= (current-idx playlist) (table-size (songs-table playlist))))
\end{myverb}

Вам не нужно добавлять блокирование в эти функции, поскольку они будут вызываться только
из функций, которые сами озаботятся блокировкой списка песен в начале работы.

Функция \lstinline{reset-current-song} использует ещё один прием: поскольку вы хотите, чтобы
список песен обеспечивал бесконечный поток MP3 к клиенту, то вам не захочется
устанавливать \lstinline{current-song} равным \lstinline{NIL}. Вместо этого, когда список песен
исчерпает себя~-- когда \lstinline{songs-table} пуст или когда последняя песня была
проиграна, а значение \lstinline{repeat} равно \lstinline{:none}, то вам нужно установить
\lstinline{current-song} равным специальной песне, чей файл с MP3 будет содержать
тишину\footnote{К сожалению, из-за лицензионных проблем вокруг формата MP3 не понятно,
  могу ли я выложить такой MP3 без уплаты лицензионных отчислений Fraunhofer IIS.  Я
  получил такой файл как часть ПО, которое шло вместе с моим Slimp3 от Slim Devices. Вы
  можете взять этот файл из их репозитория Subversion:
  \url{http://svn.slimdevices.com/*checkout*/trunk/server/HTML/EN/html/silentpacket.mp3?rev=2}.
  Или купите Squeezebox, новую, беспроводную версию Slimp3, и вы получите
  \lstinline{silentpacket.mp3} как часть ПО, которое идёт вместе с ним. Или найдите MP3-версию
  песни 4'33", John Cage'а.}\hspace{\footnotenegspace} и чьё название объяснит, почему музыка не играет.  Вот код,
который определяет два параметра: \lstinline{*empty-playlist-song*} и
\lstinline{*end-of-playlist-song*}, каждый из которых указывает на песню, хранящуюся в файле
\lstinline{*silence-mp3*}, и имеет соответствующее название:

\begin{myverb}
(defparameter *silence-mp3* ...)

(defun make-silent-song (title &optional (file *silence-mp3*))
  (make-instance
   'song 
   :file file
   :title title
   :id3-size (if (id3-p file) (size (read-id3 file)) 0)))

(defparameter *empty-playlist-song* (make-silent-song "Playlist empty."))

(defparameter *end-of-playlist-song* (make-silent-song "At end of playlist."))
\end{myverb}

Функция \lstinline{reset-current-song} использует эти параметры, когда \lstinline{current-idx} не
указывает на строку в \lstinline{songs-table}.  В~противном случае она устанавливает
\lstinline{current-song} в значение, соответствующее текущей строке.

\begin{myverb}
(defun reset-current-song (playlist)
  (setf
   (current-song playlist) 
   (cond
     ((empty-p playlist) *empty-playlist-song*)
     ((at-end-p playlist) *end-of-playlist-song*)
     (t (row->song (nth-row (current-idx playlist) (songs-table playlist)))))))

(defun row->song (song-db-entry)
  (with-column-values (file song artist album id3-size) song-db-entry
    (make-instance
     'song
     :file file
     :title (format nil "~a by ~a from ~a" song artist album)
     :id3-size id3-size)))

(defun empty-p (playlist)
  (zerop (table-size (songs-table playlist))))
\end{myverb}

Наконец-то вы можете реализовать метод \lstinline{maybe-move-to-next-song}, который перемещает
\lstinline{current-idx} к следующему значению, основываясь на режиме повторения в списке песен,
а затем вызывает \lstinline{update-current-if-necessary}.  Вы не будете изменять
\lstinline{current-idx}, когда он уже в конце списка песен, поскольку вы хотите сохранить его
текущее значение, так что он будет указывать на следующую песню, которую вы добавите к
списку песен.  Эта функция должна заблокировать список песен до внесения изменений,
поскольку она будет вызвана сервером Shoutcast server code, который не делает никаких
блокировок.

\begin{myverb}
(defmethod maybe-move-to-next-song (song (playlist playlist))
  (with-playlist-locked (playlist)
    (when (still-current-p song playlist)
      (unless (at-end-p playlist)
        (ecase (repeat playlist)
          (:song) ; nothing changes
          (:none (incf (current-idx playlist)))
          (:all  (setf (current-idx playlist)
                       (mod (1+ (current-idx playlist))
                            (table-size (songs-table playlist)))))))
      (update-current-if-necessary playlist))))
\end{myverb}

\section{Изменение списка песен}
\label{ch29:change-song-list}

Остальная часть кода плей-листа~-- это функции, которые используются веб-интерфейсом, чтобы
выполнять действия с объектами \lstinline{playlist}, включая добавление и удаление песен,
сортировку и перемешивание, а также установку режима повтора. Как во вспомогательных
функциях предыдущей секции, вам не нужно беспокоиться о блокировке и в этих функциях,
потому что, как вы увидите, блокировка будет включена в функциях веб-интерфейса, вызывающих
эти.

Добавление и удаление~-- это в основном вопрос управления списком песен. Единственная
дополнительная работа, которую вам нужно сделать,~-- это держать синхронизированными
\lstinline{current-song} и \lstinline{current-idx}. Например, когда плей-лист пустой, его
\lstinline{current-idx} будет 0, а \lstinline{current-song} будет \lstinline{*empty-playlist-song*}. Если
вы добавите песню в пустой плейлист, тогда нулевой индекс попадает в границы, и вы должны
изменить \lstinline{current-song} на только что добавленную песню. К тому же если вы проиграли все
песни в плейлисте и в \lstinline{current-song} значение \lstinline{*end-of-playlist-song*},
добавление песни должно вызвать сброс \lstinline{current-song}. Все это на самом деле означает, что
вам нужно вызывать \lstinline{update-current-if-necessary} в соответствующих местах. 

Добавление песен в плей-лист немного запутано из-за способа, которым веб-интерфейс узнает
выбранную песню. По причинам, которые я оговорю в следующей секции, код веб-интерфейса просто
не может дать вам простой набор критериев для выборки песен из базы данных. Вместо этого он дает
вам имя колонки и список значений, а вы должны добавить все песни из главной базы данных,
где данная колонка имеет значение в списке значений. Таким образом, чтобы добавить
правильные песни, вам нужно сначала построить объект таблицы с нужными значениями, который
вы можете потом использовать во внутреннем запросе к базе данных песен. Итак,
\lstinline{add-songs} выглядит следующим образом:

\begin{myverb}
(defun add-songs (playlist column-name values)
  (let ((table (make-instance
                'table 
                :schema (extract-schema (list column-name) (schema *mp3s*)))))
    (dolist (v values) (insert-row (list column-name v) table))
    (do-rows (row (select :from *mp3s* :where (in column-name table)))
      (insert-row row (songs-table playlist))))
  (update-current-if-necessary playlist))
\end{myverb}

Удаление песен немного проще; вам только нужна возможность удалять песни из
\lstinline{songs-table}, которые удовлетворяют конкретному критерию,~-- или конкретную песню, или
все песни в конкретном жанре, по конкретному исполнителю или из конкретного альбома. Итак,
вы можете предоставить функцию \lstinline{delete-songs}, которая берет пары ключ/значение,
которые используются для построения сравнительного условия \lstinline{:where} для передачи в функцию
базы данных \lstinline{delete-rows}.

Другая сложность, которая возникает при удалении песен,~-- это то, что может быть необходимость
в изменении \lstinline{current-idx}. Допуская, что текущая песня не из тех, которые только что
удалили, вам бы хотелось оставить текущую песню. Но если песни перед ней в
\lstinline{songs-table} удалены, она будет на другой позиции в таблице после удаления. Итак,
после вызова \lstinline{delete-rows} вам нужно будет посмотреть на строку, содержащую текущую
песню, и сбросить \lstinline{current-idx}. Если текущая песня сама была удалена, тогда, за
неимением лучшего варианта, вы можете сбросить \lstinline{current-idx} к нулю. После обновления
\lstinline{current-idx} вызов \lstinline{update-current-if-necessary} позаботится об обновлении
\lstinline{current-song}. И если \lstinline{current-idx} изменился, но все же указывает на ту же
песню, \lstinline{current-song} не будет затронута.

\begin{myverb}
(defun delete-songs (playlist &rest names-and-values)
  (delete-rows
   :from (songs-table playlist)
   :where (apply #'matching (songs-table playlist) names-and-values))
  (setf (current-idx playlist) (or (position-of-current playlist) 0))
  (update-current-if-necessary playlist))

(defun position-of-current (playlist)
  (let* ((table (songs-table playlist))
         (matcher (matching table :file (file (current-song playlist))))
         (pos 0))
    (do-rows (row table)
      (when (funcall matcher row)
        (return-from position-of-current pos))
      (incf pos))))
\end{myverb}

Вы также можете предоставить функцию для полного очищения плей-листа, которая использует
\lstinline{delete-all-rows} и не должна беспокоиться о поиске текущей песни, поскольку очевидно,
что она будет удалена. Вызов \lstinline{update-current-if-necessary} позаботится об
установлении \lstinline{current-song} в NIL.

\begin{myverb}
(defun clear-playlist (playlist)
  (delete-all-rows (songs-table playlist))
  (setf (current-idx playlist) 0)
  (update-current-if-necessary playlist))
\end{myverb}

Сортировка и перемешивание плей-листа связаны тем, что плей-лист всегда либо отсортирован,
либо перемешан. Слот \lstinline{shuffle} говорит, был ли плей-лист перемешан, и если так, то каким
образом. Если он установлен в \lstinline{:none}, тогда плей-лист отсортирован в соответствии со
значением слота сортировки. Если \lstinline{shuffle} равен \lstinline{:song}, плей-лист будет
случайным образом перемешан. И когда он установлен в \lstinline{:album}, список альбомов
случайным образом перемешан, но песни каждого альбома отображаются по порядку. Таким
образом, функция \lstinline{sort-playlist}, которая будет вызываться кодом веб-интерфейса, когда
пользователь будет выбирать новый порядок сортировки, должна установить порядок сортировки
в нужный и установить \lstinline{shuffle} в \lstinline{:none} перед вызовом \lstinline{order-playlist},
который на самом деле не сортирует. Так же как и в \lstinline{delete-songs}, вам нужно
использовать \lstinline{position-of-current} для сброса \lstinline{current-idx} в новую позицию
текущей песни. Тем не менее в этот раз вы не нуждаетесь в вызове
\lstinline{update-current-if-necessary}, поскольку вы знаете, что текущая песня все еще в
таблице.

\begin{myverb}
(defun sort-playlist (playlist ordering)
  (setf (ordering playlist) ordering)
  (setf (shuffle playlist) :none)
  (order-playlist playlist)
  (setf (current-idx playlist) (position-of-current playlist)))
\end{myverb}

В~\lstinline{order-playlist} вы можете использовать функцию базы данных \lstinline{sort-rows}, чтобы
действительно совершить сортировку, передавая список колонок для сортировки в зависимости
от значения \lstinline{ordering}.

\begin{myverb}
(defun order-playlist (playlist)
  (apply #'sort-rows (songs-table playlist)
    (case (ordering playlist)
      (:genre  '(:genre :album :track))
      (:artist '(:artist :album :track))
      (:album  '(:album :track))
      (:song   '(:song)))))
\end{myverb}

Функция \lstinline{shuffle-playlist}, которая вызывается кодом веб-интерфейса, когда
пользователь выбирает новый режим перемешивания, работает аналогичным образом, кром того
что не нуждается в изменении значения \lstinline{ordering}. Таким образом, когда
\lstinline{shuffle-playlist} вызывается с \lstinline{shuffle}, равным \lstinline{:none}, плей-лист
возвращается к сортировке в соответствии с предыдущим \lstinline{ordering}. Перемешивание песен
простое~-- нужно только вызвать \lstinline{shuffle-table} для \lstinline{songs-table}.
Перемешивание альбомов немножко запутаннее, но все же не ядерная физика.

\begin{myverb}
(defun shuffle-playlist (playlist shuffle)
  (setf (shuffle playlist) shuffle)
  (case shuffle
    (:none (order-playlist playlist))
    (:song (shuffle-by-song playlist))
    (:album (shuffle-by-album playlist)))
  (setf (current-idx playlist) (position-of-current playlist)))

(defun shuffle-by-song (playlist)
  (shuffle-table (songs-table playlist)))

(defun shuffle-by-album (playlist)
  (let ((new-table (make-playlist-table)))
    (do-rows (album-row (shuffled-album-names playlist))
      (do-rows (song (songs-for-album playlist (column-value album-row :album)))
        (insert-row song new-table)))
    (setf (songs-table playlist) new-table)))

(defun shuffled-album-names (playlist)
  (shuffle-table 
   (select
    :columns :album
    :from (songs-table playlist)
    :distinct t)))

(defun songs-for-album (playlist album)
  (select
   :from (songs-table playlist) 
   :where (matching (songs-table playlist) :album album)
   :order-by :track))
\end{myverb}

Последняя манипуляция, которую вам необходимо поддерживать,~-- это установка режима
повтора для плей-листа. Большую часть времени вы не нуждаетесь в дополнительных действиях,
когда устанавливаете повтор,~-- его значение входит в игру только в
\lstinline{maybe-move-to-next-song}.  Тем не менее вам нужно обновить
\lstinline{current-song} как результат изменения повтора в одной ситуации, а именно если
\lstinline{current-idx} в конце непустого плей-листа и повтор изменяется с
\lstinline{:song} или \lstinline{:all}. В~этом случае вы хотите продолжить проигрывание,
повторяя последнюю песню, или стартовать с самого начала плей-листа. Итак, вы должны
определить метод \lstinline{:after} для обобщенной функции \lstinline{(setf repeat)}.

\begin{myverb}
(defmethod (setf repeat) :after (value (playlist playlist))
  (if (and (at-end-p playlist) (not (empty-p playlist)))
    (ecase value
      (:song (setf (current-idx playlist) (1- (table-size (songs-table playlist)))))
      (:none)
      (:all  (setf (current-idx playlist) 0)))
    (update-current-if-necessary playlist)))
\end{myverb}

Теперь вы имеете все основные кусочки, которые нужны. Все это остается в коде, который
предоставит пользовательский веб-интерфейс для просмотра базы данных MP3 и обработку
плей-листов. Интерфейс будет состоять из трех главных функций, определенных с помощью
\lstinline{define-url-function}: одна~-- для просмотра базы данных песен, одна~-- для просмотра и
обработки одного плей-листа и одна~-- для списка всех доступных плей-листов.

Но, прежде чем вы начнете писать эти три функции, вам нужно начать с некоторых
вспомогательных функций и HTML-макросов для использования внутри этих функций.

\section{Типы параметров запроса}

Поскольку вы будете использовать \lstinline{define-url-function}, вам нужно определить
несколько методов для обобщенной функции \lstinline{string->type} с главы~\ref{ch:28},
которые \lstinline{define-url-function} использует для преобразования строки параметров
запроса в объекты Lisp. В~этом приложении вам нужны будут методы для преобразования строк
в целые числа, ключевые символы и списки значений.

Первые два достаточно просты.

\begin{myverb}
(defmethod string->type ((type (eql 'integer)) value)
  (parse-integer (or value "") :junk-allowed t))

(defmethod string->type ((type (eql 'keyword)) value)
  (and (plusp (length value)) (intern (string-upcase value) :keyword)))
\end{myverb}

Последний метод \lstinline{string->type}  немного более сложный. Из-за причин, к которым доберусь
через мгновение, вам нужно генерировать страницы, которые отображают форму со скрытым
полем, значение которого~-- список строк. Поскольку вы ответственны за генерацию значения в
скрытом поле и за ее разбор, когда она будет возвращена, вы можете использовать любую
удобную кодировку. Вы можете использовать функции \lstinline{WRITE-TO-STRING} и
\lstinline{READ-FROM-STRING}, которые используют процедуру чтения и механизм вывода Lisp для записи
и считывания данных со строк, кроме того что печатное представление строк может вмещать
знаки кавычек и другие символы, которые могут вызвать проблемы, будучи внутри значения
атрибута элемента \lstinline{INPUT}. Итак, вам нужно экранировать как-то такие значения. Перед
тем как придумывать свой способ экранирования, вы можете просто использовать base64,
кодировку, обычно используемую для защиты двоичных данных, посылаемых по e-mail. AllegroServe
имеет две функции, \lstinline{base64-encode} и \lstinline{base64-decode}, которые делают кодирование
и декодирование для вас; таким образом, все, что вам нужно сделать,~-- это написать пару
функций: одна кодирует объект Lisp, превращая его в читабельную строку с
\lstinline{WRITE-TO-STRING}, а потом кодирует ее с base64 и обратно, другая для декодирования
такой строки из base64 и передачи результата декодирования в \lstinline{READ-FROM-STRING}. Вам
захочется обернуть вызовы к \lstinline{WRITE-TO-STRING} и \lstinline{READ-FROM-STRING} в
\lstinline{WITH-STANDARD-IO-SYNTAX}, для того чтобы быть уверенными, что все переменные, которые
влияют на механизмы чтения и вывода, установлены в свои стандартные значения. Тем не менее,
поскольку вы собираетесь читать данные, которые приходят из сети, вы, разумеется, хотите
выключить одну функцию процедуры чтения~-- возможность выполнения произвольного кода Lisp во
время чтения\footnote{Считыватель поддерживает неполный синтаксис, \lstinline!#.!,
который заставляет выполнение s-выражения, идущего за ним во время чтения кода. Это иногда
полезно в исходном коде, но явно открывает большую дыру в безопасности, когда вы считываете
ненадежные данные. Тем не менее вы можете выключить этот синтаксис, установив значение
\lstinline{*READ-EVAL} в \lstinline{NIL}, что заставит процедуру чтения сгенерировать ошибку, когда он
встретит \lstinline!#.!.}\hspace{\footnotenegspace}! Вы можете определить собственный макрос
\lstinline{with-safe-io-syntax}, который обернет формы тела макроса в
\lstinline{WITH-STANDARD-IO-SYNTAX} внутри кода \lstinline{LET}, который привяжет \lstinline{*READ-EVAL} к
значению \lstinline{NIL}.

\begin{myverb}
(defmacro with-safe-io-syntax (&body body)
  `(with-standard-io-syntax
     (let ((*read-eval* nil))
       ,@body)))
\end{myverb}

В~таком случае функции кодирования и декодирования тривиальны.

\begin{myverb}
(defun obj->base64 (obj)
  (base64-encode (with-safe-io-syntax (write-to-string obj))))

(defun base64->obj (string)
  (ignore-errors
    (with-safe-io-syntax (read-from-string (base64-decode string)))))
\end{myverb}

Наконец, вы можете использовать эти функции для определения метода для
\lstinline!string->type!, который определит преобразование для типа параметра запроса
\lstinline{base64-list}

\begin{myverb}
(defmethod string->type ((type (eql 'base-64-list)) value)
  (let ((obj (base64->obj value)))
    (if (listp obj) obj nil)))
\end{myverb}

\section{Шаблонный HTML}

Дальше вам нужно определить некоторые HTML-макросы и вспомогательные функции, чтобы было
просто придать разным страницам приложения единообразный внешний вид. Вы можете начать с
HTML-макроса, который определяет базовую структуру страницы приложения.

\begin{myverb}
(define-html-macro :mp3-browser-page ((&key title (header title)) &body body)
  `(:html
     (:head
      (:title ,title)
      (:link :rel "stylesheet" :type "text/css" :href "mp3-browser.css"))
     (:body
      (standard-header)
      (when ,header (html (:h1 :class "title" ,header)))
      ,@body
      (standard-footer))))
\end{myverb}

Вам нужно определить \lstinline{standard-header} и \lstinline{standard-footer} как отдельные функции
по двум причинам. Во-первых, в процессе разработки вы можете переопределить эти функции и
посмотреть эффект без надобности перекомпилировать функции, которые используют
макрос \lstinline{:mp3-browser-page}. Во-вторых, как мы увидим позже, одна из страниц, которые
мы напишем, не будет определена с \lstinline{:mp3-browser-page}, но все же будет нуждаться в
стандартной шапке и нижней части сайта. Они имеют следующий вид:

\begin{myverb}
(defparameter *r* 25)

(defun standard-header ()
  (html
   ((:p :class "toolbar")
    "[" (:a :href (link "/browse" :what "genre") "All genres") "] "
    "[" (:a :href (link "/browse" :what "genre" :random *r*) "Random genres") "] "
    "[" (:a :href (link "/browse" :what "artist") "All artists") "] "
    "[" (:a :href (link "/browse" :what "artist" :random *r*) "Random artists") "] "
    "[" (:a :href (link "/browse" :what "album") "All albums") "] "
    "[" (:a :href (link "/browse" :what "album" :random *r*) "Random albums") "] "
    "[" (:a :href (link "/browse" :what "song" :random *r*) "Random songs") "] "
    "[" (:a :href (link "/playlist") "Playlist") "] "
    "[" (:a :href (link "/all-playlists") "All playlists") "]")))

(defun standard-footer ()
  (html (:hr) ((:p :class "footer") "MP3 Browser v" *major-version* "." *minor-version*)))
\end{myverb}

Несколько HTML-макросов поменьше и вспомогательных функций автоматизируют другие общие
шаблоны. HTML-макрос \lstinline{:table-row} делает проще работу по генерации одной строки для
таблицы. Он использует возможность FOO, о которой я поговорю в главе~\ref{ch:31},
параметр \lstinline!&attributes!, который позволит превращать вызовы макроса в нормальные
s-выражения для представления HTML-форм, с любыми свойствами, которые собираются в список и
привязываются к параметру \lstinline!&attributes!. Вот как это выглядит:

\begin{myverb}
(define-html-macro :table-row (&attributes attrs &rest values)
  `(:tr ,@attrs ,@(loop for v in values collect `(:td ,v))))
\end{myverb}

А функция \lstinline{link} генерирует URL для приложения, который будет использоваться как
атрибут \lstinline{HREF} элементат \lstinline{A}, она строит строку запроса по набору пар
ключ/значение и позволяет нам быть уверенными, что все специальные символы правильно
экранированы. Например, вместо того чтобы писать это:

\begin{myverb}
(:a :href "browse?what=artist&genre=Rhythm+%26+Blues" "Artists")
\end{myverb}

\noindent{}вы можете писать следующее:

\begin{myverb}
(:a :href (link "browse" :what "artist" :genre "Rhythm & Blues") "Artists")
\end{myverb}

Выглядит функция так:

\begin{myverb}
(defun link (target &rest attributes)
  (html 
    (:attribute
     (:format "~a~@[?~{~(~a~)=~a~^&~}~]" target (mapcar #'urlencode attributes)))))
\end{myverb}

Чтобы кодировать для URL ключи и значения, вы используете функцию \lstinline{urlencode},
которая является оберткой над функцией \lstinline{encode-form-urlencoded}, это непубличная
функция из AllegroServe. Это~-- с одной стороны~-- плохая форма; поскольку имя
\lstinline{encode-form-urlencoded} не экспортировано с \lstinline{NET.ASERVE}, возможно, что
\lstinline{encode-form-urlencoded} может быть удалена или переименована без вашего уведомления.
С другой стороны, использование неэкспортированного символа пока позволяет вам
сделать работу прямо сейчас; путем обертывания \lstinline{encode-form-urlencoded} в свою
собственную функцию вы изолируете код, который может стать неработоспособным, в одну
функцию, которую сможете переписать, когда будет нужно.

\begin{myverb}
(defun urlencode (string)
  (net.aserve::encode-form-urlencoded string))
\end{myverb}

Наконец, вам нужна CSS-таблица стилей mp3-browser.css, используемая на странице
\lstinline{:mp3-browser-page}. Поскольку в ней нет ничего динамического, наверное, самое
простое, что можем сделать,~-- это опубликовать статический файл с помощью
\lstinline{publish-file}:

\begin{myverb}
(publish-file :path "/mp3-browser.css"  :file filename :content-type "text/css")
\end{myverb}

Пример таблицы стилей вложен в исходный код для этой главы на веб-сайте книги. Вы
определите функцию в конце этой главы, которая запускает приложение MP3 браузера. Она
побеспокоится, кроме всего прочего, о публикации данного файла.

\section{Страница просмотра}

Первая URL-функция будет генерировать страницу для просмотра базы данных MP3. Ее параметры
запроса скажут ей, что именно пользователь просматривает, и скажут какими элементами в
базе данных он интересуется. Это даст возможность выбора записей, которые принадлежат к
какому-то жанру, какому-то исполнителю или альбому. Ради интереса вы также можете
определить способ выбора случайного под\-мно\-жес\-тва нужных записей. Когда пользователь
просматривает на уровне конкретных песен, заголовок песни будет ссылкой, которая сделает
добавление песни в плей-лист. Иначе каждый элемент будет представлен со ссылками, которые
позволят пользователю просматривать элементы списка по какой-то другой категории.
Например, если пользователь просматривает жанры, запись <<Блюз>> будет содержать ссылки
для просмотра всех альбомов, исполнителей и песен в жанре блюз. Кроме того, страница
просмотра предоставит кнопку <<Добавить все>>, которая добавит каждую песню, согласно
фильтру страницы, к плей-листу пользователя. Функция выглядит следующим образом:

\begin{myverb}
(define-url-function browse
    (request (what keyword :genre) genre artist album (random integer))

  (let* ((values (values-for-page what genre artist album random))
         (title (browse-page-title what random genre artist album))
         (single-column (if (eql what :song) :file what))
         (values-string (values->base-64 single-column values)))
    (html
     (:mp3-browser-page
      (:title title)
      ((:form :method "POST" :action "playlist")
       (:input :name "values" :type "hidden" :value values-string)
       (:input :name "what" :type "hidden" :value single-column)
       (:input :name "action" :type "hidden" :value :add-songs)
       (:input :name "submit" :type "submit" :value "Add all"))
      (:ul (do-rows (row values) (list-item-for-page what row)))))))
\end{myverb}

Эта функция запускается при использовании функции \lstinline{values-for-page} для получения
таблицы, содержащей значения, которые она должна представить. Когда пользователь
просматривает по песне~-- когда параметр \lstinline{what} имеет значение \lstinline{:song},~-- вы
хотите выбрать все строки из базы данных. Но когда они делают просмотр по жанру,
исполнителю или альбому, вы хотите выбрать только конкретные значения для данной
категории. Функция базы данных для выбора делает большую часть тяжелой работы, с
\lstinline{values-for-page} больше ответственной за передачу правильных аргументов в
зависимости от значения \lstinline{what}. Она также является местом, где вы выбираете случайное
подмножество подходящих строк, если нужно:

\begin{myverb}
(defun values-for-page (what genre artist album random)
  (let ((values
         (select 
          :from *mp3s*
          :columns (if (eql what :song) t what)
          :where (matching *mp3s* :genre genre :artist artist :album album)
          :distinct (not (eql what :song))
          :order-by (if (eql what :song) '(:album :track) what))))
    (if random (random-selection values random) values)))
\end{myverb}

Для генерации заголовка страницы просмотра вы передаете фильтр просмотра следующей
функции, \lstinline{browse-page-title}:

\begin{myverb}
(defun browse-page-title (what random genre artist album)
  (with-output-to-string (s)
    (when random (format s "~:(~r~) Random " random))
    (format s "~:(~a~p~)" what random)
    (when (or genre artist album)
      (when (not (eql what :song)) (princ " with songs" s))
      (when genre  (format s " in genre ~a" genre))
      (when artist (format s " by artist ~a " artist))
      (when album  (format s " on album ~a" album)))))
\end{myverb}

Когда у вас будут значения для отображения, вам захочется сделать с ними две вещи. Главная
задача конечно, представить их, что случается в цикле \lstinline{do-rows}, оставляя
отображение каждой строки функции \lstinline{list-item-for-page}. Функция отображает строки
\lstinline{:song} одним способом и другим способом~-- все остальные. 

\begin{myverb}
(defun list-item-for-page (what row)
  (if (eql what :song)
    (with-column-values (song file album artist genre) row
      (html
        (:li
         (:a :href (link "playlist" :file file :action "add-songs") (:b song)) " from "
         (:a :href (link "browse"  :what :song :album  album) album) " by "
         (:a :href (link "browse" :what :song :artist artist) artist) " in genre "
         (:a :href (link "browse"  :what :song :genre  genre) genre))))
    (let ((value (column-value row what)))
      (html
       (:li value " - "
            (browse-link :genre  what value)
            (browse-link :artist what value)
            (browse-link :album  what value)
            (browse-link :song   what value))))))

(defun browse-link (new-what what value)
  (unless (eql new-what what)
    (html
     "[" 
     (:a :href (link "browse" :what new-what what value) (:format "~(~as~)" new-what))
     "] ")))
\end{myverb}

Другая вещь на странице просмотра~-- это форма с несколькими скрытыми полями \lstinline{INPUT} и
кнопка-подтверждение <<Добавить все>>. Вам нужно использовать HTML-форму вместо обычной
ссылки, чтобы приложение не сохраняло состояния~-- для того чтобы убедиться, что вся
информация, нужная для ответа на запрос, приходит в самом запросе. Поскольку результаты
страницы просмотра могут быть частично случайными, вам нужно отослать добрую долю данных
на сервер, чтобы иметь возможность восстановить список песен для добавления в плей-лист.
Если вы не делали генерацию случайных результатов для страницы просмотра, вам не нужно
много данных~-- вы могли бы просто отослать запрос для добавления песен по любому запросу
поиска со страницы просмотра. Но если вы добавляли песни этим способом, с фильтром, который
включал случайный аргумент, тогда в результате будет добавлен другой набор случайных песен,
который бы отличался от того, что пользователь видел на странице при нажатии кнопки
<<Добавить все>>.

Решение, которое вы будете использовать,~-- это отослать назад форму, которая имеет достаточно
информации, спрятанной в скрытом (hidden) элементе \lstinline{INPUT}, чтобы позволить серверу
восстановить список песен, которые удовлетворяли фильтр страницы просмотра. Эта
информация~-- список значений, возвращаемых \lstinline{values-for-page}, и значение параметра
\lstinline{what}. Это место, где вы используете тип параметра \lstinline{base64-list}; функция
\lstinline{values->base64} добывает значения конкретной колонки из таблицы, возвращаемой
\lstinline{values-for-page} в список, а тогда делает base64-кодированную строку из этого списка
для включения в форму.

\begin{myverb}
(defun values->base-64 (column values-table)
  (flet ((value (r) (column-value r column)))
    (obj->base64 (map-rows #'value values-table))))
\end{myverb}

Когда этот параметр возвращается обратно как значение параметра запроса \lstinline{values}
в URL-функцию, которая определяет \lstinline{values} как тип \lstinline{base-64-list}, он
будет автоматически преобразован назад в список. Как вы увидите через мгновение, этот
список может быть использован для построения запроса, который отобразит правильный список
песен\footnote{Это решение имеет свои недостатки~-- если страница просмотра отдает много
  результатов, добрый кусок данных идет туда и обратно на самом деле. Также запросы базы
  данных не всегда наиболее производительны. Но это позволяет приложению не сохранять
  состояние. Альтернативный подход~-- при просмотре запастись на стороне сервера
  информацией о возвращенных результатах, а потом, когда придет запрос на добавление,
  найти соответствующие части информации, для того чтобы воссоздать правильный набор
  песен. Например, вы можете просто сохранить список значений, вместо того чтобы отсылать
  его назад формой. Или вы можете скопировать объект \lstinline{RANDOM-STATE} перед
  генерацией результатов просмотра, чтобы потом воссоздать <<случайные>> результаты. Но
  этот подход причиняет свои проблемы. Например, вам бы нужно было беспокоиться о том, как
  избавиться от сохраненной информации; вы не знаете, когда пользователь может нажать
  кнопку <<назад>> в браузере для возвращения на старую страницу и потом нажать кнопку
  <<Добавить все>>. Милости просим в мир веб-программирования.}\hspace{\footnotenegspace}. Когда вы просматриваете
по \lstinline{:song}, то используете значения из колонки \lstinline{:file}, поскольку они
уникально определяют сами песни, тогда как названия песен могут этого не делать.

\section{Плей-лист}

Итак, я подошел к следующей URL-функции, плей-листу. Это наиболее сложная страница из
трех~-- она отвечает за отображение текущего содержания плей-листа пользователя, а также за
предоставление интерфейса для управления плей-листом. Но так как \lstinline{define-url-function}
обрабатывает рутинную работу, не так сложно увидеть, как работает плей-лист. Вот начало
определения, только со списком параметров: 

\begin{myverb}
(define-url-function playlist 
    (request
     (playlist-id string (playlist-id request) :package)
     (action keyword)      ; Playlist manipulation action
     (what keyword :file)  ; for :add-songs action
     (values base-64-list) ;             "
     file                  ; for :add-songs and :delete-songs actions
     genre                 ; for :delete-songs action
     artist                ;             "
     album                 ;             "
     (order-by keyword)    ; for :sort action
     (shuffle keyword)     ; for :shuffle action
     (repeat keyword))     ; for :set-repeat action
\end{myverb}

В~дополнение к обязательному параметру \lstinline{request} плей-лист принимает
дополнительный набор параметров запроса.  Наиболее важным в своем роде является параметр
\lstinline{playlist-id}, который определяет, каким из объектов \lstinline{playlist} будет
отображать и управлять страница. Для этого параметра вы можете использовать преимущества
возможности функции \lstinline{define-url-function} <<липкий параметр>>. Обычно
\lstinline{playlist-id} не будет обязательно передан и возьмет значение по умолчанию, то
есть IP-адрес клиентской машины, на которой запущен браузер. Тем не менее пользователи
могут также управлять плей-листами из других машин, кроме тех, на которых запущены
MP3-клиенты, если мы позволим изменить это значение. И если значение уже указано,
\lstinline{define-url-function} организует его <<приклеивание>> путем установки cookie в
браузере. Позже вы определите URL-функцию, которая будет генерировать список всех
существующих плей-листов, которые пользователи смогут использовать для выбора плей-листа,
отличного от того, который на их машине.

Параметр \lstinline{action} указывает некоторое действие, которое нужно делать над объектом
пользовательского плей-листа. Значение этого параметра, которое будет преобразовано в
ключевой символ для вас, может быть \lstinline{:add-songs}, \lstinline{:delete-songs},
\lstinline{:clear}, \lstinline{:sort}, \lstinline{:shuffle} или \lstinline{:set-repeat}. Действие
\lstinline{:add-songs} используется в кнопке <<Добавить все>> на странице просмотра, а также
ссылками для добавления конкретных песен. Другие действия используются ссылками на самой
странице плей-листа.

Параметры \lstinline{file}, \lstinline{what} и \lstinline{values} используются с действием
\lstinline{:add-songs}. Определяя \lstinline{values} как \lstinline{base-64-list}, инфраструктура функции
\lstinline{define-url-function} позаботится о перекодировании значения, отосланного с помощью
формы <<Добавить все>>. Другие параметры используются с другими действиями, как было указано
в комментариях.

Теперь давайте посмотрим на тело плей-листа. Первое, что вам нужно,~-- это использовать
\lstinline{playlist-id}, для того чтобы найти объект очереди, и затем сделать блокировку
плей-листа следующими двумя линиями:

\begin{myverb}
(let ((playlist (lookup-playlist playlist-id)))
  (with-playlist-locked (playlist)
\end{myverb}

Поскольку \lstinline{lookup-playlist} создаст новый плей-лист по необходимости, она всегда
возвратит объект \lstinline{playlist}. Тогда вам нужно позаботиться о необходимых манипуляциях
с очередью, используя значения параметра \lstinline{action} для вызова одной из функций
плей-листа.

\begin{myverb}
(case action
  (:add-songs      (add-songs playlist what (or values (list file))))
  (:delete-songs   (delete-songs 
                    playlist 
                    :file file :genre genre
                    :artist artist :album album))
  (:clear          (clear-playlist playlist))
  (:sort           (sort-playlist playlist order-by))
  (:shuffle        (shuffle-playlist playlist shuffle))
  (:set-repeat     (setf (repeat playlist) repeat)))
\end{myverb}

Все, что осталось для функции \lstinline{playlist},~-- это сама генерация HTML. Опять же вы можете
использовать HTML-макрос \lstinline{:mp3-browser-page}, чтобы убедиться, что основной вид
страницы похож на другие страницы приложения, но в этот раз вы передаете \lstinline{NIL} в
параметр \lstinline{:header}, чтобы пропустить \lstinline{H1} заголовок. Вот остаток кода функции:

\begin{myverb}
(html
 (:mp3-browser-page
  (:title (:format "Playlist - ~a" (id playlist)) :header nil)
  (playlist-toolbar playlist)
  (if (empty-p playlist)
    (html (:p (:i "Empty.")))
    (html 
      ((:table :class "playlist")
       (:table-row "#" "Song" "Album" "Artist" "Genre")
       (let ((idx 0)
             (current-idx (current-idx playlist)))
         (do-rows (row (songs-table playlist))
           (with-column-values (track file song album artist genre) row
             (let ((row-style (if (= idx current-idx) "now-playing" "normal")))
               (html
                 ((:table-row :class row-style)
                  track
                  (:progn song   (delete-songs-link :file file))
                  (:progn album  (delete-songs-link :album album))
                  (:progn artist (delete-songs-link :artist artist))
                  (:progn genre  (delete-songs-link :genre genre)))))
             (incf idx))))))))))))
\end{myverb}

Функция \lstinline{playlist-toolbar} генерирует панель инструментов, содержащую ссылки на
плей-лист для выполнения различных \lstinline{:action} манипуляций. А функция
\lstinline{delete-songs-link} генерирует ссылку на плей-лист с параметром \lstinline{:action},
содержащим значение \lstinline{:delete-songs}, и соответствующими аргументами для удаления
конкретного файла, или всех файлов, или альбома, или композиций конкретного исполнителя или
принадлежащих какому-то жанру.

\begin{myverb}
(defun playlist-toolbar (playlist)
  (let ((current-repeat (repeat playlist))
        (current-sort (ordering playlist))
        (current-shuffle (shuffle playlist)))
    (html
     (:p :class "playlist-toolbar"
         (:i "Sort by:")
         " [ "
         (sort-playlist-button "genre" current-sort) " | " 
         (sort-playlist-button "artist" current-sort) " | " 
         (sort-playlist-button "album" current-sort) " | " 
         (sort-playlist-button "song" current-sort) " ] "
         (:i "Shuffle by:")
         " [ "
         (playlist-shuffle-button "none" current-shuffle) " | "
         (playlist-shuffle-button "song" current-shuffle) " | "
         (playlist-shuffle-button "album" current-shuffle) " ] "
         (:i "Repeat:")
         " [ "
         (playlist-repeat-button "none" current-repeat) " | "
         (playlist-repeat-button "song" current-repeat) " | "
         (playlist-repeat-button "all" current-repeat) " ] "
         "[ " (:a :href (link "playlist" :action "clear") "Clear") " ] "))))

(defun playlist-button (action argument new-value current-value)
  (let ((label (string-capitalize new-value)))
    (if (string-equal new-value current-value)
      (html (:b label))
      (html (:a :href (link "playlist" :action action argument new-value) label)))))

(defun sort-playlist-button (order-by current-sort)
  (playlist-button :sort :order-by order-by current-sort))

(defun playlist-shuffle-button (shuffle current-shuffle)
  (playlist-button :shuffle :shuffle shuffle current-shuffle))

(defun playlist-repeat-button (repeat current-repeat)
  (playlist-button :set-repeat :repeat repeat current-repeat))

(defun delete-songs-link (what value)
  (html " [" (:a :href (link "playlist" :action :delete-songs what value) "x") "]"))
\end{myverb}

\section{Находим плей-лист}

Последняя из трех URL-функций наиболее проста. Она представляет табличный список всех
плей-листов, которые были созданы. Обычно пользователи могут обойтись и без этой страницы, но
во время разработки она дает полезный вид состояния системы. Она также предоставляет
механизм для изменения текущего плей-листа: каждый ID плей-листа~- это ссылка на страницу
плей-листа с заданным параметром строки запроса \lstinline{playlist-id}, который будет потом
<<приклеенным>> функцией URL плей-листа. Обратите внимание, что вам нужно получить
\lstinline{*playlists-lock*}, чтобы быть уверенным, что хэш-таблица \lstinline{*playlists*} не
была изменена, пока вы проходили по ней. 

\begin{myverb}
(define-url-function all-playlists (request)
  (:mp3-browser-page
   (:title "All Playlists")
   ((:table :class "all-playlists")
    (:table-row "Playlist" "# Songs" "Most recent user agent")
    (with-process-lock (*playlists-lock*)
      (loop for playlist being the hash-values of *playlists* do
           (html
             (:table-row
              (:a :href (link "playlist" :playlist-id (id playlist)) (:print (id playlist)))
              (:print (table-size (songs-table playlist)))
              (:print (user-agent playlist)))))))))
\end{myverb}

\section{Запускаем приложение}

И вот оно. Чтобы использовать это приложение, вам нужно просто загрузить базу данных MP3 с
помощью функции \lstinline{load-database} из главы~\ref{ch:27}, опубликовать таблицу
стилей CSS, установить \lstinline{*song-source-type*} в \lstinline{playlist}, чтобы
\lstinline{find-song-source} использовала плей-листы вместо единичного песенного источника,
определенного в прошлой главе, и запустить AllegroServe. Следующая функция заботится обо всех
этих вещах для вас, после того как вы заполните соответствующими значениями два
параметра, \lstinline{*mp3-dir*}, корневую папку MP3-коллекции и \lstinline{*mp3-css*}, имя файла
таблицы стилей CSS:

\begin{myverb}
(defparameter *mp3-dir* ...)

(defparameter *mp3-css* ...)

(defun start-mp3-browser ()
  (load-database *mp3-dir* *mp3s*)
  (publish-file :path "/mp3-browser.css"  :file *mp3-css* :content-type "text/css")
  (setf *song-source-type* 'playlist)
  (net.aserve::debug-on :notrap)
  (net.aserve:start :port 2001))
\end{myverb}

Когда вы сделаете вызов этой функции, она будет печатать точки, пока будет загружаться
ID3-информация с ваших ID3-файлов. После этого вы можете открыть в MP3-клиенте следующий
URL:

\begin{myverb}
  http://localhost:2001/stream.mp3
\end{myverb}

\noindent{}и заставить браузер перейти на какое-то хорошое стартовое место, как это:

\begin{myverb}
  http://localhost:2001/browse
\end{myverb}

\noindent{}что позволит запустить просмотр категории по умолчанию, <<Жанр>>. После того как вы
добавите некоторые песни в плей-лист, вы можете нажать <<Играть>> в MP3-клиенте и он должен
начать проигрывать первую песню. 

Очевидно, вы можете улучшить пользовательский интерфейс несколькими способами~-- например,
если у вас много MP3 в библиотеке, может быть полезным просматривать исполнителей или
альбомы по первой букве их имен/названий. Или вы можете добавить кнопку <<Играть весь
альбом>> на страницу плей-листа, которая сделает, чтобы все песни из того же альбома, что и
текущая песня, добавились в начало плей-листа. Или вы можете изменить класс \lstinline{playlist},
так что вместо тишины, когда песен нет в очереди, он будет выбирать случайную песню из базы
данных. Но все эти идеи попадают в область проектирования приложения, которая на самом деле
не тема этой книги. Но следующие две главы отбросят нас на уровень инфраструктуры программ
чтобы показать как работает библиотека FOO для генерации HTML.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pcl-ru"
%%% TeX-open-quote: "<<"
%%% TeX-close-quote: ">>"
%%% End: 
